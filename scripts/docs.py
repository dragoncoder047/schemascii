#! /usr/bin/env python3
from __future__ import annotations

import datetime
import os
import sys

from scriptutils import spit

try:
    sys.path.append(os.path.realpath(os.path.pardir))
    import schemascii  # noqa: F401
    from schemascii.component import Component
    from schemascii.data_consumer import (_OPT_IS_REQUIRED, DataConsumer,
                                          Option, OptionsSet)
except ModuleNotFoundError:
    # dummy to prevent isort from putting the
    # imports above the sys.path.append
    raise


def uniq_sameorder[T](xs: list[T]) -> list[T]:
    return sorted(set(xs), key=lambda x: xs.index(x))


def reverse_dict[K, V](d: dict[K, V]) -> dict[V, K]:
    return {v: k for k, v in d.items()}


def output_file(filename: os.PathLike, heading: str, content: str):
    spit(filename, f"""# {heading}

<!-- markdownlint-disable no-emphasis-as-heading -->
*This file was automatically generated by scripts/docs.py on {
        datetime.datetime.now().ctime()}*
""" + content)


def get_scopes_for_cls(cls: type[DataConsumer]):
    return [k for k, v in DataConsumer.registry.items() if v in cls.mro()]


def format_option(opt: Option) -> str:
    typename = (opt.type.__name__
                if isinstance(opt.type, type)
                else " or ".join(f"`{z!s}`" for z in opt.type))
    items: list[str] = [opt.name, typename, opt.help, "*required*"]
    if opt.default is not _OPT_IS_REQUIRED:
        items[-1] = (repr(opt.default)
                     if opt.default is not None
                     else "(no value)")
    return f"| {' | '.join(items)} |\n"


def format_scope(scopename: str, options: OptionsSet,
                 interj: str, head: str) -> str:
    scope_text = f"""
## {head} `{scopename}`{"\n\n" + interj if interj else ""}

| Option | Value | Description | Default |
|:------:|:-----:|:------------|:-------:|
"""
    for option in options.self_opts:
        scope_text += format_option(option)
    return scope_text


def get_RDs_for_cls(cls: type[Component]) -> list[str]:
    return [k for k, v in Component.all_components.items() if v is cls]


def classes_inorder():
    return uniq_sameorder(sorted(DataConsumer.registry.values(),
                                 key=lambda cls: len(cls.mro())))


def format_inherited_options(
        inherited_options: dict[str, list[Option]]) -> str:
    out: list[str] = []
    for namespace, options in inherited_options.items():
        option_names = ", ".join(f"`{opt.name}`" for opt in options)
        out.append(f"* copies {option_names} from `{namespace}`")
    return "\n".join(out)


def generate_class_docs() -> str:
    """
    Generate documentation for all classes in DataConsumer.registry.
    """
    content = ""
    class_to_namespace = reverse_dict(DataConsumer.registry)
    defined_options = {}  # Track defined options to avoid redefinition

    for cls in classes_inorder():
        if getattr(cls, "not_for_docs", False):
            continue

        # Collect unique options
        unique_options = [
            opt for opt in cls.options.self_opts
            if opt.name not in defined_options]
        for opt in unique_options:
            defined_options[opt.name] = class_to_namespace.get(
                cls, cls.__name__)

        # Collect inherited options
        inherited_options = {}
        base_cls: type[DataConsumer]
        for base_cls in cls.mro()[1:]:
            if base_cls in DataConsumer.registry.values():
                namespace = class_to_namespace.get(base_cls, base_cls.__name__)
                inherited = cls.options.inherit if isinstance(
                    cls.options.inherit, set) else None
                base_options = [
                    opt for opt in base_cls.options.self_opts
                    if opt.name not in defined_options and (
                        inherited is None or opt.name in inherited)]
                if base_options:
                    inherited_options[namespace] = base_options
                    for opt in base_options:
                        defined_options[opt.name] = namespace

        # Format the scope for the class
        scopes = "` or `".join(get_scopes_for_cls(cls))
        heading = "Component" if issubclass(
            cls, Component) and cls is not Component else "Scope"
        content += format_scope(
            scopes,
            cls.options,
            format_inherited_options(inherited_options),
            heading,
        )
        content += "".join(format_option(opt) for opt in unique_options)

    return content


def main():
    output_file("options.md", "Data Section Options", generate_class_docs())


if __name__ == '__main__':
    main()
