#! /usr/bin/env python3
from __future__ import annotations

import datetime
import os
import sys
from pprint import pprint

# TODO: this is an awful mess
# need to clean it up so it actually produces useful documentation

from scriptutils import spit

try:
    sys.path.append(os.path.realpath(os.path.pardir))
    import schemascii  # noqa: F401
    from schemascii.component import Component
    from schemascii.data_consumer import (_OPT_IS_REQUIRED, DataConsumer,
                                          Option, OptionsSet)
except ModuleNotFoundError:
    # dummy to prevent isort from putting the
    # imports above the sys.path.append
    raise


def uniq_sameorder[T](xs: list[T]) -> list[T]:
    return sorted(set(xs), key=lambda x: xs.index(x))


def output_file(filename: os.PathLike, heading: str, content: str):
    spit(filename, f"""# {heading}

<!-- markdownlint-disable no-emphasis-as-heading -->
*This file was automatically generated by scripts/docs.py on {
        datetime.datetime.now().ctime()}*
""" + content)


def get_scopes_for_cls(cls: type[DataConsumer]):
    return [k for k, v in DataConsumer.registry.items() if v in cls.mro()]


def format_option(opt: Option) -> str:
    typename = (opt.type.__name__
                if isinstance(opt.type, type)
                else " or ".join(f"`{z!s}`" for z in opt.type))
    items: list[str] = [opt.name, typename, opt.help, "*required*"]
    if opt.default is not _OPT_IS_REQUIRED:
        items[-1] = (repr(opt.default)
                     if opt.default is not None
                     else "(no value)")
    return f"| {' | '.join(items)} |\n"


def format_scope(scopename: str, options: OptionsSet,
                 interj: str, head: str) -> str:
    scope_text = f"""
## {head} `{scopename.upper()}`{"\n\n" + interj if interj else ""}

| Option | Value | Description | Default |
|:------:|:-----:|:------------|:-------:|
"""
    for option in options.self_opts:
        scope_text += format_option(option)
    if options.inherit:
        classes = [p.__name__ for p in options.inherit_from]
        if isinstance(options.inherit, bool):
            vt = "values"
        else:
            vt = ", ".join(f"`{x}`" for x in sorted(options.inherit))
        scope_text += f"""
Inherits {vt} from: {", ".join(classes)}
"""
    return scope_text


def get_RDs_for_cls(cls: type[Component]) -> list[str]:
    return [k for k, v in Component.all_components.items() if v is cls]


def classes_inorder():
    return uniq_sameorder(sorted(DataConsumer.registry.values(),
                                 key=lambda cls: len(cls.mro())))


def main():
    pprint(("in order", classes_inorder()))
    content: str = ""
    classes: list[type[DataConsumer]] = sorted(
        set(DataConsumer.registry.values()),
        key=lambda cls: cls.__name__)
    print("all classes: ", classes)
    for d in classes:
        if "not_for_docs" in d.__dict__ and d.not_for_docs:
            continue
        scopes = get_scopes_for_cls(d)
        s = "` or `".join(scopes)
        rds_line = ""
        heading = "Scope"
        if issubclass(d, Component) and d is not Component:
            rds = get_RDs_for_cls(d)
            s = "` or `".join(sc for sc in scopes if sc not in rds)
            heading = "Component"
            rds_line = "Reference Designators: "
            rds_line += ", ".join(f"`{x}`" for x in rds)
        content += format_scope(s, d.options, rds_line, heading)

    output_file("options.md", "Data Section Options", content)


if __name__ == '__main__':
    main()
